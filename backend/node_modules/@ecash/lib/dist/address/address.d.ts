import { Script } from '../script';
export type AddressType = 'p2pkh' | 'p2sh';
export type AddressEncoding = 'cashaddr' | 'legacy';
export declare const ECASH_PREFIXES_TESTNET: string[];
/**
 * Converts an ecash address in cashaddr format to legacy format
 * Throws if user attempts to convert a legacy address to a legacy address
 * Separated as its own function here for
 *
 * 1 - simpler unit testing
 * 2 - exported for users looking to convert string cashaddr to string legacy addr
 *     without using the Address class
 */
export declare const toLegacyAddress: (cashaddress: string) => string;
interface AddressInterface {
    /**
     * hash
     * The hash this address encodes as a hex string.
     * It's part of the Script this address represents.
     */
    hash: string;
    /**
     * p2pkh or p2sh
     * The type of address
     * Address supports p2pkh or p2sh address types
     */
    type: AddressType;
    /**
     * Defined for a cashaddr address, i.e. one with encoding === 'cashaddr'
     * This is distinct from the version byte. Common prefixes on ecash include
     * 'ecash', 'etoken', 'ectest', and 'ecregest'. But a prefix could be anything
     * so long as the address checksum matches.
     */
    prefix?: string;
    /**
     * encoded address as a string
     * cashaddr or legacy
     * type available in 'encoding' field
     */
    address: string;
    /**
     * How this address is encoded
     * cashaddr or legacy
     * If cashaddr, 'prefix' is defined and a string
     */
    encoding: AddressEncoding;
}
export declare const DEFAULT_PREFIX = "ecash";
/**
 * Address
 * Stores properties of supported crypto addresses
 * in standard typed structure. Provides methods for
 * easy access of address data in dev-friendly formats.
 * Provides methods for instantiating by type, encoding,
 * script, prefix, and address string of arbitrary encoding.
 *
 * Simplifies conversion between cashaddr prefixes and
 * address encoding types.
 *
 * Address is an ecash-first class. Legacy BTC format
 * is supported to simplify conversion to and from
 * ecash addresses.
 *
 * Address may be extended to support other crypto
 * address formats.
 */
export declare class Address implements AddressInterface {
    hash: string;
    type: AddressType;
    prefix?: string;
    address: string;
    encoding: AddressEncoding;
    private constructor();
    /**
     * Create a new p2pkh Address from hash
     * cashaddr encoding, ecash: prefix
     */
    static p2pkh: (hash: string | Uint8Array) => Address;
    /**
     * Create a new p2sh Address from hash
     * cashaddr encoding
     * ecash: prefix
     */
    static p2sh: (hash: string | Uint8Array) => Address;
    /**
     * Create a new Address from a given address string
     * address must be valid legacy or cashaddr address
     */
    static parse: (address: string) => Address;
    /**
     * Create a new Address from a cashaddr
     * prefix, type, and hash from creating cashaddr
     */
    static fromCashAddress: (address: string) => Address;
    /**
     * Create a new Address from legacy address
     * No prefix for Address created from legacy address
     * type and hash from legacy address
     */
    static fromLegacyAddress: (legacy: string) => Address;
    /**
     * Create a new Address from an outputScript as Script
     * type and hash from outputScript
     * cashaddr encoding
     * ecash: prefix
     */
    static fromScript: (script: Script) => Address;
    /**
     * Create a new Address from an outputScript as hex string
     * type and hash from outputScript
     * cashaddr encoding
     * ecash: prefix
     */
    static fromScriptHex: (scriptHex: string) => Address;
    toString: () => string;
    legacy: () => Address;
    /**
     * Create an Address with cashaddr encoding
     * from an existing Address
     */
    cash: () => Address;
    /**
     * Create address with specified prefix
     * from an existing cashaddr-encoding Address
     */
    withPrefix: (prefix: string) => Address;
    toScript: () => Script;
    toScriptHex: () => string;
}
export {};
//# sourceMappingURL=address.d.ts.map