import { Ecc } from './ecc.js';
import { Script } from './script.js';
import { SigHashType } from './sigHashType.js';
import { Tx, TxInput, TxOutput } from './tx.js';
import { UnsignedTxInput } from './unsignedTx.js';
/**
 * Function that contains all the required data to sign a given `input` and
 * return the scriptSig.
 *
 * Use it by attaching a `Signatory` to a TxBuilderInput, e.g. like this for a
 * P2PKH input:
 * ```ts
 * new TxBuilder({
 *     inputs: [{
 *         input: { prevOut: ... },
 *         signatory: P2PKHSignatory(sk, pk, ALL_BIP143),
 *     }],
 *     ...
 * })
 * ```
 **/
export type Signatory = (ecc: Ecc, input: UnsignedTxInput) => Script;
/** Builder input that bundles all the data required to sign a TxInput */
export interface TxBuilderInput {
    input: TxInput;
    signatory?: Signatory;
}
/**
 * Output that can either be:
 * - `TxOutput`: A full output with a fixed sats amount
 * - `Script`: A Script which will receive the leftover sats after fees.
 *   Leftover usually is the change the sender gets back from providing more
 *   sats than needed.
 */
export type TxBuilderOutput = TxOutput | Script;
/** Class that can be used to build and sign txs. */
export declare class TxBuilder {
    /** nVersion of the resulting Tx */
    version: number;
    /** Inputs that will be signed by the buider */
    inputs: TxBuilderInput[];
    /**
     * Outputs of the tx, can specify a single leftover (i.e. change) output as
     * a Script.
     **/
    outputs: TxBuilderOutput[];
    /** nLockTime of the resulting Tx */
    locktime: number;
    constructor(params?: {
        version?: number;
        inputs?: TxBuilderInput[];
        outputs?: TxBuilderOutput[];
        locktime?: number;
    });
    /** Calculte sum of all sats coming in, or `undefined` if some unknown. */
    private inputSum;
    private prepareOutputs;
    /** Sign the tx built by this builder and return a Tx */
    sign(ecc: Ecc, feePerKb?: number, dustLimit?: number): Tx;
}
/** Calculate the required tx fee for the given txSize and feePerKb,
 *  rounding up */
export declare function calcTxFee(txSize: number, feePerKb: number): bigint;
/** Append the sighash flags to the signature */
export declare function flagSignature(sig: Uint8Array, sigHashFlags: SigHashType): Uint8Array;
/**
 * Sign the sighash using Schnorr for BIP143 signatures and ECDSA for Legacy
 * signatures, and then flags the signature correctly
 **/
export declare function signWithSigHash(ecc: Ecc, sk: Uint8Array, sigHash: Uint8Array, sigHashType: SigHashType): Uint8Array;
/** Signatory for a P2PKH input. Always uses Schnorr signatures */
export declare const P2PKHSignatory: (sk: Uint8Array, pk: Uint8Array, sigHashType: SigHashType) => (ecc: Ecc, input: UnsignedTxInput) => Script;
/** Signatory for a P2PK input. Always uses Schnorr signatures */
export declare const P2PKSignatory: (sk: Uint8Array, sigHashType: SigHashType) => (ecc: Ecc, input: UnsignedTxInput) => Script;
//# sourceMappingURL=txBuilder.d.ts.map