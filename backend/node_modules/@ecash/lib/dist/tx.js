"use strict";
// Copyright (c) 2024 The Bitcoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyTxOutput = exports.copyTxInput = exports.writeTxOutput = exports.writeTxInput = exports.writeOutPoint = exports.readTxOutput = exports.Tx = exports.DEFAULT_TX_VERSION = exports.DEFAULT_SEQUENCE = void 0;
const hex_js_1 = require("./io/hex.js");
const varsize_js_1 = require("./io/varsize.js");
const writerbytes_js_1 = require("./io/writerbytes.js");
const writerlength_js_1 = require("./io/writerlength.js");
const script_js_1 = require("./script.js");
/**
 * Default value for nSequence of inputs if left undefined; this opts out of
 * BIP68 relative lock-time, and if all inputs have this value, nLockTime is
 * disabled, too.
 *
 * This is chosen as the default as it's the default in the node too,
 * see CTxIn in /src/primitives/transaction.h.
 **/
exports.DEFAULT_SEQUENCE = 0xffffffff;
/** Current tx version, see CTransaction in /stc/primitives/transaction.h */
exports.DEFAULT_TX_VERSION = 2;
/** CTransaction, a Bitcoin transaction. */
class Tx {
    constructor(params) {
        this.version = params?.version ?? exports.DEFAULT_TX_VERSION;
        this.inputs = params?.inputs ?? [];
        this.outputs = params?.outputs ?? [];
        this.locktime = params?.locktime ?? 0;
    }
    /** Serialize the tx to a byte array */
    ser() {
        const writerBytes = new writerbytes_js_1.WriterBytes(this.serSize());
        this.write(writerBytes);
        return writerBytes.data;
    }
    /** Calculate the serialized size of the tx */
    serSize() {
        const writerLength = new writerlength_js_1.WriterLength();
        this.write(writerLength);
        return writerLength.length;
    }
    /** Write the tx to the given writer */
    write(writer) {
        writer.putU32(this.version);
        (0, varsize_js_1.writeVarSize)(this.inputs.length, writer);
        for (const input of this.inputs) {
            writeTxInput(input, writer);
        }
        (0, varsize_js_1.writeVarSize)(this.outputs.length, writer);
        for (const output of this.outputs) {
            writeTxOutput(output, writer);
        }
        writer.putU32(this.locktime);
    }
}
exports.Tx = Tx;
function readTxOutput(bytes) {
    const value = bytes.readU64();
    const script = script_js_1.Script.readWithSize(bytes);
    return {
        value,
        script,
    };
}
exports.readTxOutput = readTxOutput;
/** Write an outpoint to a Writer */
function writeOutPoint(outpoint, writer) {
    const txid = typeof outpoint.txid === 'string'
        ? (0, hex_js_1.fromHexRev)(outpoint.txid)
        : outpoint.txid;
    writer.putBytes(txid);
    writer.putU32(outpoint.outIdx);
}
exports.writeOutPoint = writeOutPoint;
/** Write a TxInput to a Writer */
function writeTxInput(input, writer) {
    writeOutPoint(input.prevOut, writer);
    (input.script ?? new script_js_1.Script()).writeWithSize(writer);
    writer.putU32(input.sequence ?? exports.DEFAULT_SEQUENCE);
}
exports.writeTxInput = writeTxInput;
/** Write a TxOutput to a Writer */
function writeTxOutput(output, writer) {
    writer.putU64(output.value);
    output.script.writeWithSize(writer);
}
exports.writeTxOutput = writeTxOutput;
/** Create a deep copy of the TxInput */
function copyTxInput(input) {
    return {
        prevOut: {
            txid: typeof input.prevOut.txid === 'string'
                ? input.prevOut.txid
                : new Uint8Array(input.prevOut.txid),
            outIdx: input.prevOut.outIdx,
        },
        script: input.script?.copy(),
        sequence: input.sequence,
        signData: input.signData && {
            value: input.signData.value,
            outputScript: input.signData.outputScript?.copy(),
            redeemScript: input.signData.redeemScript?.copy(),
        },
    };
}
exports.copyTxInput = copyTxInput;
/** Create a deep copy of the TxOutput */
function copyTxOutput(output) {
    return {
        value: output.value,
        script: output.script.copy(),
    };
}
exports.copyTxOutput = copyTxOutput;
//# sourceMappingURL=tx.js.map