"use strict";
// Copyright (c) 2024 The Bitcoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.
Object.defineProperty(exports, "__esModule", { value: true });
exports.alpBurn = exports.alpSend = exports.alpMint = exports.alpGenesis = exports.ALP_STANDARD = exports.ALP_LOKAD_ID = void 0;
const hex_js_1 = require("../io/hex.js");
const str_js_1 = require("../io/str.js");
const writerbytes_js_1 = require("../io/writerbytes.js");
const writerlength_js_1 = require("../io/writerlength.js");
const common_js_1 = require("./common.js");
/** LOKAD ID for ALP */
exports.ALP_LOKAD_ID = (0, str_js_1.strToBytes)('SLP2');
/** ALP standard token type number */
exports.ALP_STANDARD = 0;
/** Build an ALP GENESIS pushdata section, creating a new ALP token */
function alpGenesis(tokenType, genesisInfo, mintData) {
    const writeSection = (writer) => {
        writer.putBytes(exports.ALP_LOKAD_ID);
        writer.putU8(tokenType);
        putVarBytes(common_js_1.GENESIS, writer);
        putVarBytes((0, str_js_1.strToBytes)(genesisInfo.tokenTicker ?? ''), writer);
        putVarBytes((0, str_js_1.strToBytes)(genesisInfo.tokenName ?? ''), writer);
        putVarBytes((0, str_js_1.strToBytes)(genesisInfo.url ?? ''), writer);
        putVarBytes((0, hex_js_1.fromHex)(genesisInfo.data ?? ''), writer);
        putVarBytes((0, hex_js_1.fromHex)(genesisInfo.authPubkey ?? ''), writer);
        writer.putU8(genesisInfo.decimals ?? 0);
        putMintData(mintData, writer);
    };
    const writerLength = new writerlength_js_1.WriterLength();
    writeSection(writerLength);
    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);
    writeSection(writerBytes);
    return writerBytes.data;
}
exports.alpGenesis = alpGenesis;
/**
 * Build an ALP MINT pushdata section, creating new ALP tokens and mint batons
 * of the given token ID.
 **/
function alpMint(tokenId, tokenType, mintData) {
    const tokenIdBytes = (0, hex_js_1.fromHexRev)(tokenId);
    const writeSection = (writer) => {
        writer.putBytes(exports.ALP_LOKAD_ID);
        writer.putU8(tokenType);
        putVarBytes(common_js_1.MINT, writer);
        writer.putBytes(tokenIdBytes);
        putMintData(mintData, writer);
    };
    const writerLength = new writerlength_js_1.WriterLength();
    writeSection(writerLength);
    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);
    writeSection(writerBytes);
    return writerBytes.data;
}
exports.alpMint = alpMint;
/**
 * Build an ALP SEND pushdata section, moving ALP tokens to different outputs
 **/
function alpSend(tokenId, tokenType, sendAmounts) {
    const tokenIdBytes = (0, hex_js_1.fromHexRev)(tokenId);
    const writeSection = (writer) => {
        writer.putBytes(exports.ALP_LOKAD_ID);
        writer.putU8(tokenType);
        writer.putU8(common_js_1.SEND.length);
        writer.putBytes(common_js_1.SEND);
        writer.putBytes(tokenIdBytes);
        writer.putU8(sendAmounts.length);
        for (const amount of sendAmounts) {
            putAlpAmount(amount, writer);
        }
    };
    const writerLength = new writerlength_js_1.WriterLength();
    writeSection(writerLength);
    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);
    writeSection(writerBytes);
    return writerBytes.data;
}
exports.alpSend = alpSend;
/** Build an ALP BURN pushdata section, intentionally burning ALP tokens. */
function alpBurn(tokenId, tokenType, burnAmount) {
    const tokenIdBytes = (0, hex_js_1.fromHexRev)(tokenId);
    const writeSection = (writer) => {
        writer.putBytes(exports.ALP_LOKAD_ID);
        writer.putU8(tokenType);
        writer.putU8(common_js_1.BURN.length);
        writer.putBytes(common_js_1.BURN);
        writer.putBytes(tokenIdBytes);
        putAlpAmount(burnAmount, writer);
    };
    const writerLength = new writerlength_js_1.WriterLength();
    writeSection(writerLength);
    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);
    writeSection(writerBytes);
    return writerBytes.data;
}
exports.alpBurn = alpBurn;
function putMintData(mintData, writer) {
    writer.putU8(mintData.amounts.length);
    for (const amount of mintData.amounts) {
        putAlpAmount(amount, writer);
    }
    writer.putU8(mintData.numBatons);
}
function putAlpAmount(amount, writer) {
    const amountN = BigInt(amount);
    writer.putU32(amountN & 0xffffffffn);
    writer.putU16(amountN >> 32n);
}
function putVarBytes(bytes, writer) {
    if (bytes.length > 127) {
        throw new Error('Length of bytes must be between 0 and 127');
    }
    writer.putU8(bytes.length);
    writer.putBytes(bytes);
}
//# sourceMappingURL=alp.js.map