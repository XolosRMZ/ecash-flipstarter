import { Script } from './script.js';
import { SigHashType } from './sigHashType.js';
import { Tx, TxInput } from './tx.js';
/** An unsigned tx, which helps us build the sighash preimage we need to sign */
export declare class UnsignedTx {
    tx: Tx;
    prevoutsHash: Uint8Array;
    sequencesHash: Uint8Array;
    outputsHash: Uint8Array;
    private constructor();
    /**
     * Make an UnsignedTx from a Tx, will precompute the fields required to
     * sign the tx
     **/
    static fromTx(tx: Tx): UnsignedTx;
    /**
     * Make a dummy UnsignedTx from a Tx, will set dummy values for the fields
     * required to sign the tx. Useful for tx size estimation.
     **/
    static dummyFromTx(tx: Tx): UnsignedTx;
    /** Return the unsigned tx input at the given input index */
    inputAt(inputIdx: number): UnsignedTxInput;
}
/** A preimage of a sighash for an input's scriptSig ready to be signed */
export interface SighashPreimage {
    /** Bytes of the serialized sighash preimage */
    bytes: Uint8Array;
    /** Script code of the preimage, with OP_CODESEPARATOR cut out */
    scriptCode: Script;
    /** Redeem script, with no modifications */
    redeemScript: Script;
}
/**
 * An unsigned tx input, can be used to build a sighash preimage ready to be
 * signed
 **/
export declare class UnsignedTxInput {
    inputIdx: number;
    unsignedTx: UnsignedTx;
    constructor(params: {
        inputIdx: number;
        unsignedTx: UnsignedTx;
    });
    /**
     * Build the sigHashPreimage for this input, with the given sigHashType
     * and OP_CODESEPARATOR index
     **/
    sigHashPreimage(sigHashType: SigHashType, nCodesep?: number): SighashPreimage;
    /** Return the TxInput of this UnsignedTxInput */
    txInput(): TxInput;
}
//# sourceMappingURL=unsignedTx.d.ts.map