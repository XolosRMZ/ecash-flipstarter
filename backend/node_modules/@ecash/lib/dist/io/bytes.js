"use strict";
// Copyright (c) 2024 The Bitcoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bytes = exports.endianToBool = void 0;
function endianToBool(endian) {
    if (!endian) {
        // By default, little endian
        return true;
    }
    return endian === 'LE';
}
exports.endianToBool = endianToBool;
/** Reads ints/bytes from a Uint8Array. All integers are little-endian. */
class Bytes {
    /** Create a new Bytes that reads from the given data */
    constructor(data) {
        this.data = data;
        this.view = new DataView(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        this.idx = 0;
    }
    /** Read a single byte */
    readU8() {
        this.ensureSize(1);
        const result = this.data[this.idx];
        this.idx++;
        return result;
    }
    /** Read 2-byte little-endian integer (uint16_t) */
    readU16(endian) {
        this.ensureSize(2);
        const result = this.view.getUint16(this.idx, endianToBool(endian));
        this.idx += 2;
        return result;
    }
    /** Read 4-byte little-endian integer (uint32_t) */
    readU32(endian) {
        this.ensureSize(4);
        const result = this.view.getUint32(this.idx, endianToBool(endian));
        this.idx += 4;
        return result;
    }
    /** Read 8-byte little-endian integer (uint64_t) */
    readU64(endian) {
        this.ensureSize(8);
        const result = this.view.getBigUint64(this.idx, endianToBool(endian));
        this.idx += 8;
        return result;
    }
    /** Read the given number of bytes as array */
    readBytes(numBytes) {
        this.ensureSize(numBytes);
        const result = this.data.slice(this.idx, this.idx + numBytes);
        this.idx += numBytes;
        return result;
    }
    ensureSize(extraBytes) {
        if (this.data.length < this.idx + extraBytes) {
            throw (`Not enough bytes: Tried reading ${extraBytes} byte(s), but ` +
                `there are only ${this.data.length - this.idx} byte(s) left`);
        }
    }
}
exports.Bytes = Bytes;
//# sourceMappingURL=bytes.js.map