import { Writer } from './io/writer.js';
import { Op } from './op.js';
import { Bytes } from './io/bytes.js';
/** A Bitcoin Script locking/unlocking a UTXO */
export declare class Script {
    bytecode: Uint8Array;
    /** Create a new Script with the given bytecode or empty */
    constructor(bytecode?: Uint8Array);
    /**
     * Write the script to the writer with the script size as VARINT
     * prepended.
     **/
    writeWithSize(writer: Writer): void;
    static readWithSize(bytes: Bytes): Script;
    /** Build a Script from the given Script Ops */
    static fromOps(ops: Op[]): Script;
    static fromAddress(address: string): Script;
    /** Iterate over the Ops of this Script */
    ops(): ScriptOpIter;
    /** Create a deep copy of this Script */
    copy(): Script;
    /**
     * Find the n-th OP_CODESEPARATOR (0-based) and cut out the bytecode
     * following it. Required for signing BIP143 scripts that have an
     * OP_CODESEPARATOR.
     *
     * Throw an error if the n-th OP_CODESEPARATOR doesn't exist.
     *
     * Historically this opcode has been seen as obscure and useless, but in
     * BIP143 sighash-based covenants, basically every covenant benefits from
     * its usage, by trimming down the sighash preimage size and thus tx size.
     *
     * Really long Scripts will have a big BIP143 preimage, which costs precious
     * bytes (and the preimage might even go over the 520 pushdata limit).
     * This can be trimmed down to just one single byte by ending the covenant
     * in `... OP_CODESEPARATOR OP_CHECKSIG`, in which case the BIP143 signature
     * algo will cut out everything after the OP_CODESEPARATOR, so only the
     * OP_CHECKSIG remains.
     * If the covenant bytecode is 520 or so, this would save 519 bytes.
     */
    cutOutCodesep(nCodesep: number): Script;
    /**
     * Whether the Script is a P2SH Script.
     * Matches CScript::IsPayToScriptHash in /src/script/script.h.
     **/
    isP2sh(): boolean;
    /**
     * Return hex string of this Script's bytecode
     */
    toHex(): string;
    /** Build a P2SH script for the given script hash */
    static p2sh(scriptHash: Uint8Array): Script;
    /** Build a P2PKH script for the given public key hash */
    static p2pkh(pkh: Uint8Array): Script;
    /** Build a scriptSig for spending a P2PKH output */
    static p2pkhSpend(pk: Uint8Array, sig: Uint8Array): Script;
}
/** Iterator over the Ops of a Script. */
export declare class ScriptOpIter {
    bytes: Bytes;
    constructor(bytes: Bytes);
    /**
     * Read the next Op and return it, or `undefined` if there are no more Ops.
     * Throws an error if reading the next op failed.
     */
    next(): Op | undefined;
}
//# sourceMappingURL=script.d.ts.map