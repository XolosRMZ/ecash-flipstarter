"use strict";
// Copyright (c) 2024 The Bitcoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ecc = exports.__setEcc = exports.EccDummy = void 0;
/** Dummy Ecc impl that always returns 0, useful for measuring tx size */
class EccDummy {
    derivePubkey(_seckey) {
        return new Uint8Array(33);
    }
    ecdsaSign(_seckey, _msg) {
        return new Uint8Array(73);
    }
    schnorrSign(_seckey, _msg) {
        return new Uint8Array(64);
    }
    isValidSeckey(_seckey) {
        return false;
    }
    seckeyAdd(_a, _b) {
        return new Uint8Array(32);
    }
    pubkeyAdd(_a, _b) {
        return new Uint8Array(32);
    }
}
exports.EccDummy = EccDummy;
const ECC = {};
function __setEcc(ecc) {
    ECC.ecc = ecc;
}
exports.__setEcc = __setEcc;
class Ecc {
    /** Derive a public key from secret key. */
    derivePubkey(seckey) {
        return ECC.ecc.derivePubkey(seckey);
    }
    /** Sign an ECDSA signature. msg needs to be a 32-byte hash */
    ecdsaSign(seckey, msg) {
        return ECC.ecc.ecdsaSign(seckey, msg);
    }
    /** Sign a Schnorr signature. msg needs to be a 32-byte hash */
    schnorrSign(seckey, msg) {
        return ECC.ecc.schnorrSign(seckey, msg);
    }
    /**
     * Return whether the given secret key is valid, i.e. whether is of correct
     * length (32 bytes) and is on the curve.
     */
    isValidSeckey(seckey) {
        return ECC.ecc.isValidSeckey(seckey);
    }
    /** Add a scalar to a secret key */
    seckeyAdd(a, b) {
        return ECC.ecc.seckeyAdd(a, b);
    }
    /** Add a scalar to a public key (adding G*b) */
    pubkeyAdd(a, b) {
        return ECC.ecc.pubkeyAdd(a, b);
    }
}
exports.Ecc = Ecc;
//# sourceMappingURL=ecc.js.map