/** Interface to abstract over Elliptic Curve Cryptography */
export interface Ecc {
    /** Derive a public key from secret key. */
    derivePubkey(seckey: Uint8Array): Uint8Array;
    /** Sign an ECDSA signature. msg needs to be a 32-byte hash */
    ecdsaSign(seckey: Uint8Array, msg: Uint8Array): Uint8Array;
    /** Sign a Schnorr signature. msg needs to be a 32-byte hash */
    schnorrSign(seckey: Uint8Array, msg: Uint8Array): Uint8Array;
    /**
     * Return whether the given secret key is valid, i.e. whether is of correct
     * length (32 bytes) and is on the curve.
     */
    isValidSeckey(seckey: Uint8Array): boolean;
    /** Add a scalar to a secret key */
    seckeyAdd(a: Uint8Array, b: Uint8Array): Uint8Array;
    /** Add a scalar to a public key (adding G*b) */
    pubkeyAdd(a: Uint8Array, b: Uint8Array): Uint8Array;
}
/** Dummy Ecc impl that always returns 0, useful for measuring tx size */
export declare class EccDummy implements Ecc {
    derivePubkey(_seckey: Uint8Array): Uint8Array;
    ecdsaSign(_seckey: Uint8Array, _msg: Uint8Array): Uint8Array;
    schnorrSign(_seckey: Uint8Array, _msg: Uint8Array): Uint8Array;
    isValidSeckey(_seckey: Uint8Array): boolean;
    seckeyAdd(_a: Uint8Array, _b: Uint8Array): Uint8Array;
    pubkeyAdd(_a: Uint8Array, _b: Uint8Array): Uint8Array;
}
export declare function __setEcc(ecc: Ecc): void;
export declare class Ecc implements Ecc {
}
//# sourceMappingURL=ecc.d.ts.map